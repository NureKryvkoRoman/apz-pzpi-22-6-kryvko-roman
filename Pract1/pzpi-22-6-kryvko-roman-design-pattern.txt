Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії
ЗВІТ
до практичного заняття з дисципліни
"Архітектура програмного забезпечення"
(завдання №1)






Виконав: ст. гр. ПЗПІ-22-6
Кривко Роман Андрійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович




Харків 2025


1 ІСТОРІЯ ЗМІН
Таблиця 1.1 Історія змін
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	07.04.2025
	0.1
	Створено основні розділи.
	2
	07.04.2025
	0.2
	Додано інформацію про проведену роботу.
	3
	07.04.2025
	0.3
	Додано посилання на відео на YouTube.
	

2 ЗАВДАННЯ
Метою практичної роботи є ознайомлення з поширеними патернами (шаблонами) проєктування та вивчення їх особливостей на прикладі патерна проєктування Memento. Задачею роботи є вивчити патерн Memento, його особливості, можливі реалізації, області застосування, переваги та недоліки.

3 ОПИС ВИКОНАНОЇ РОБОТИ
Патерни (шаблони) проєктування — це типові рішення для поширених проблем, які виникають під час розробки програмного забезпечення. Темою цієї роботи є шаблон Memento (Знімок), що належить до категорії поведінкових патернів - патернів, які описують способи взаємодії між об'єктами в програмі. Ці патерни зосереджуються на розподілі відповідальностей та ефективній комунікації між об'єктами, зберігаючи при цьому слабкий зв'язок між ними з метою зробити систему більш гнучкою, зрозумілою та легкою для змін.
Основна мета шаблону Memento — зберігати і відновлювати попередній стан об’єкта без порушення принципу інкапсуляції, записуючи внутрішній стан оригінального об’єкта в окремий об’єкт-знімок. Це дозволяє, наприклад, реалізувати функції «скасувати дію» або «відновити дію» у застосунках, коли потрібно повернутися до попереднього стану об’єкта без прямого доступу до його внутрішньої структури. Основна ідея полягає в тому, що зовнішній об'єкт (зазвичай той, що керує станом іншого об’єкта) може зберігати історію змін і відновлювати попередні стани без прямого доступу до внутрішніх змінних, таким чином зберігаючи інкапсуляцію.
Прикладом з реального світу для патерну Memento може бути текстовий редактор з функцією «скасувати дію» або «відновити дію». Уявімо, що користувач працює з текстом у редакторі, додає або видаляє слова. Кожного разу, коли відбувається зміна, редактор може зберегти знімок поточного стану тексту. Якщо користувач натискає кнопку "Відмінити", редактор повертається до попереднього збереженого стану, не втручаючись у внутрішню логіку об’єкта, який зберігає текст.
Патерн Memento складається з трьох основних компонентів: «Джерело», «Знімок», «Керівник».


Рисунок 3.1 - UML-діаграма патерну Memento
Джерело — це клас, стан якого потрібно зберігати та відновлювати. Він створює об'єкти типу «Знімок» (Memento), що містять знімки його поточного стану, і також має можливість відновити свій стан із переданого знімка.
Знімок — це клас, який зберігає внутрішній стан об'єкта «Джерело». Він зазвичай має лише приватні поля та не надає відкритого доступу до своїх даних іншим класам. Це гарантує збереження інкапсуляції — один із принципів ООП. 
Керівник — це клас, який керує знімками стану. Він зберігає об’єкти Memento, але не має доступу до їхнього вмісту. Основна його задача — зберігати історію змін і надавати Memento назад об'єкту-джерела Originator, коли потрібно відновити стан.

4 ВИСНОВКИ
        Отже, під час виконання практичного завдання нами було розглянуто шаблон проєктування Memento — інструмент, який можна застосовувати, коли важливо зберігати та відновлювати стан об'єктів. Посилання на відеозапис презентації наведено у додатку А, слайди презентації у додатку Б, приклад реалізації (програмний код) — у додатку В.
________________
ДОДАТОК А
Відеозапис доповіді на YouTube: https://youtu.be/FLjPKpiKYis
Хронологічний опис доповіді:
00:00 - Вступ
00:19 - Тема презентації. Патерн Memento
00:40 - Детальний огляд патерну Memento
01:26 - Приклад з  реального світу
01:57 - Основні компоненти патерну Memento
02:15 - Складова "Джерело" (Originator)
02:59 - Складова "Знімок" (Memento)
03:37 - Складова "Керівник" (Caretaker)
04:20 - UML діаграма
04:43 - Приклад коду
05:22 - Коли варто застосовувати патерн
06:03 - Переваги патерну Memento
06:34 - Недоліки патерну Memento
07:11 - Підсумки
________________
ДОДАТОК Б
  

Рисунок Б.1 - Титульний слайд
Рисунок Б.2 - Що таке Memento    
  

Рисунок Б.3 - Шаблон Memento
  

Рисунок Б.4 - Приклад з реального світу
  
Рисунок Б.5 - Складові Memento. Джерело


  
Рисунок Б.6 - Складові Memento. Змінок

  
Рисунок Б.7 - Складові Memento. Керівник
  
Рисунок Б.8 - UML-діаграма
  
Рисунок Б.9 - Приклад коду. Джерело


  

Рисунок Б.10 - Приклад коду. Знімок
  
Рисунок Б.11 - Приклад коду. Керівник
  
Рисунок Б.12 - Переваги Memento

  

Рисунок Б.13 - Недоліки Memento
________________
ДОДАТОК В
Memento.java
 1        package ua.nure.kryvko.roman;
 2        public class Memento {
 3            private final String text;
 4            public Memento(String text) {
 5                this.text = text;
 6            }
 7            public String getData() {
 8                return text;
 9            }
10        }


Originator.java
 1        package ua.nure.kryvko.roman;
 2        public class Originator {
 3            private String text;
 4            public Originator()
 5            {
 6           }
 7            public void setText(String newText) {
 8                text = newText;
 9            }
10            public void removeText() {
11                text = "";
12            }
13            public String getText() {
14                return text;
15            }
16            public Memento saveState() {
17                return new Memento(text);
18            }
19            public void restore(Memento memento) {
20                text = memento.getData();
21            }
22        }

Caretaker.java
 1        package ua.nure.kryvko.roman;
 2        import java.util.Stack;
 3        public class Caretaker {
 4            private Originator originator;
 5            private Stack<Memento> history;
 6            public Caretaker(Originator originator) {
 7                this.originator = originator;
 8                history = new Stack<>();
 9            }
10            public void makeSnapshot() {
11                Memento oldState = originator.saveState();
12                history.add(oldState);
13            }
14            public void undo() {
15                if (!history.empty()) {
16                    Memento memento = history.pop();
17                    originator.restore(memento);
18                }
19            }
20        }
